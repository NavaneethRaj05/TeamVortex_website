const express = require('express');
const router = express.Router();
const Chatbot = require('../models/Chatbot');
const Event = require('../models/Event');
const ClubInfo = require('../models/ClubInfo');

// Helper function to calculate string similarity (Levenshtein distance based)
function calculateSimilarity(str1, str2) {
    const s1 = str1.toLowerCase().trim();
    const s2 = str2.toLowerCase().trim();
    
    // Exact match
    if (s1 === s2) return 1.0;
    
    // Contains match
    if (s1.includes(s2) || s2.includes(s1)) return 0.8;
    
    // Word match
    const words1 = s1.split(/\s+/);
    const words2 = s2.split(/\s+/);
    const commonWords = words1.filter(word => words2.includes(word));
    
    if (commonWords.length > 0) {
        return commonWords.length / Math.max(words1.length, words2.length);
    }
    
    // Levenshtein distance for fuzzy matching
    const distance = levenshteinDistance(s1, s2);
    const maxLength = Math.max(s1.length, s2.length);
    return 1 - (distance / maxLength);
}

// Levenshtein distance algorithm
function levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
            }
        }
    }
    
    return matrix[str2.length][str1.length];
}

// Helper function to find best matching FAQ
function findBestMatch(query, faqs) {
    let bestMatch = null;
    let bestScore = 0;

    for (const faq of faqs) {
        if (!faq.enabled) continue;

        // Check question similarity
        let score = calculateSimilarity(query, faq.question);

        // Check keywords
        if (faq.keywords && faq.keywords.length > 0) {
            for (const keyword of faq.keywords) {
                const keywordScore = calculateSimilarity(query, keyword);
                score = Math.max(score, keywordScore);
            }
        }

        if (score > bestScore) {
            bestScore = score;
            bestMatch = faq;
        }
    }

    return { match: bestMatch, score: bestScore };
}

// Helper function to check if query matches learned interactions with ML improvement
async function checkLearnedInteractions(query, chatbot) {
    if (!chatbot.settings.mlEnabled) return null;
    
    let bestMatch = null;
    let bestScore = 0;
    
    for (const learned of chatbot.learnedInteractions) {
        if (!learned.approved || !learned.suggestedAnswer) continue;
        
        const similarity = calculateSimilarity(query, learned.userQuery);
        
        // Also check related queries
        for (const relatedQuery of learned.relatedQueries) {
            const relatedSimilarity = calculateSimilarity(query, relatedQuery);
            if (relatedSimilarity > similarity) {
                similarity = relatedSimilarity;
            }
        }
        
        if (similarity > bestScore) {
            bestScore = similarity;
            bestMatch = learned;
        }
    }
    
    if (bestMatch && bestScore > (chatbot.settings.similarityThreshold || 0.7)) {
        // Update frequency
        bestMatch.frequency += 1;
        
        // ML Enhancement: Select best answer based on feedback
        let responseText = bestMatch.suggestedAnswer;
        
        // If there are auto-generated answers with good confidence, consider them
        if (bestMatch.autoGeneratedAnswers && bestMatch.autoGeneratedAnswers.length > 0) {
            const bestAutoAnswer = bestMatch.autoGeneratedAnswers
                .sort((a, b) => b.confidence - a.confidence)[0];
            
            if (bestAutoAnswer.confidence > 0.8) {
                responseText = bestAutoAnswer.answer;
            }
        }
        
        await chatbot.save();
        
        return {
            response: responseText,
            source: 'learned',
            confidence: bestScore,
            learnedId: bestMatch._id // For feedback tracking
        };
    }
    
    return null;
}

// Helper function to record unresolved query for ML learning with pattern recognition
async function recordUnresolvedQuery(query, chatbot, context = {}) {
    if (!chatbot.settings.mlEnabled) return;
    
    // Check if similar query already exists
    let existingQuery = null;
    let highestSimilarity = 0;
    
    for (const learned of chatbot.learnedInteractions) {
        const similarity = calculateSimilarity(query, learned.userQuery);
        if (similarity > highestSimilarity) {
            highestSimilarity = similarity;
            if (similarity > 0.85) { // Very similar
                existingQuery = learned;
            }
        }
    }
    
    if (existingQuery) {
        // Increment frequency of existing query
        existingQuery.frequency += 1;
        if (!existingQuery.relatedQueries.includes(query)) {
            existingQuery.relatedQueries.push(query);
        }
        
        // ML Enhancement: Try to auto-generate answer from similar FAQs
        if (chatbot.settings.enableAutoImprovement && !existingQuery.suggestedAnswer) {
            const autoAnswer = await tryAutoGenerateAnswer(query, chatbot);
            if (autoAnswer) {
                existingQuery.autoGeneratedAnswers.push(autoAnswer);
            }
        }
    } else {
        // Add new learned interaction
        const newLearned = {
            userQuery: query,
            frequency: 1,
            timestamp: new Date(),
            relatedQueries: [],
            autoGeneratedAnswers: []
        };
        
        // Try to auto-generate answer
        if (chatbot.settings.enableAutoImprovement) {
            const autoAnswer = await tryAutoGenerateAnswer(query, chatbot);
            if (autoAnswer) {
                newLearned.autoGeneratedAnswers.push(autoAnswer);
            }
        }
        
        chatbot.learnedInteractions.push(newLearned);
        chatbot.analytics.learnedQueries += 1;
    }
    
    chatbot.analytics.unresolvedQueries += 1;
    
    // Auto-create FAQ if threshold reached
    const autoThreshold = chatbot.settings.autoLearnThreshold || 3;
    if (existingQuery && existingQuery.frequency >= autoThreshold && !existingQuery.approved) {
        // Mark for admin review
        existingQuery.category = 'general';
        
        // If we have a high-confidence auto-generated answer, auto-approve it
        if (existingQuery.autoGeneratedAnswers.length > 0) {
            const bestAnswer = existingQuery.autoGeneratedAnswers
                .sort((a, b) => b.confidence - a.confidence)[0];
            
            if (bestAnswer.confidence > 0.85) {
                existingQuery.suggestedAnswer = bestAnswer.answer;
                existingQuery.approved = true;
            }
        }
    }
    
    // ML Enhancement: Update query patterns
    await updateQueryPatterns(query, chatbot);
    
    await chatbot.save();
}

// ML Enhancement: Try to auto-generate answer from similar FAQs
async function tryAutoGenerateAnswer(query, chatbot) {
    // Find similar FAQs
    const similarFAQs = [];
    
    for (const faq of chatbot.customFAQs) {
        if (!faq.enabled) continue;
        
        const similarity = calculateSimilarity(query, faq.question);
        
        if (similarity > 0.6) {
            similarFAQs.push({
                faq,
                similarity,
                qualityScore: faq.qualityScore || 0
            });
        }
    }
    
    if (similarFAQs.length === 0) return null;
    
    // Sort by similarity and quality
    similarFAQs.sort((a, b) => {
        const scoreA = (a.similarity * 0.7) + (a.qualityScore * 0.3);
        const scoreB = (b.similarity * 0.7) + (b.qualityScore * 0.3);
        return scoreB - scoreA;
    });
    
    const bestMatch = similarFAQs[0];
    
    // If similarity is high enough, use that answer
    if (bestMatch.similarity > 0.75) {
        return {
            answer: bestMatch.faq.answer,
            confidence: bestMatch.similarity,
            source: 'similar_faq',
            timestamp: new Date()
        };
    }
    
    return null;
}

// ML Enhancement: Update query patterns for better matching
async function updateQueryPatterns(query, chatbot) {
    const queryLower = query.toLowerCase();
    const words = queryLower.split(/\s+/).filter(w => w.length > 3);
    
    if (words.length === 0) return;
    
    // Extract key phrases (2-3 word combinations)
    const phrases = [];
    for (let i = 0; i < words.length - 1; i++) {
        phrases.push(words[i] + ' ' + words[i + 1]);
        if (i < words.length - 2) {
            phrases.push(words[i] + ' ' + words[i + 1] + ' ' + words[i + 2]);
        }
    }
    
    // Update pattern frequency
    for (const phrase of phrases) {
        let pattern = chatbot.queryPatterns.find(p => p.pattern === phrase);
        
        if (pattern) {
            pattern.frequency += 1;
            pattern.lastUpdated = new Date();
        } else {
            chatbot.queryPatterns.push({
                pattern: phrase,
                frequency: 1,
                category: 'general',
                confidence: 0,
                lastUpdated: new Date()
            });
        }
    }
}

// Helper function to get automatic responses from website data
async function getAutomaticResponse(query) {
    const queryLower = query.toLowerCase();

    // Greeting queries - handle casual greetings
    const greetings = ['hi', 'hello', 'hey', 'hii', 'hiii', 'helo', 'hola', 'namaste', 'good morning', 'good afternoon', 'good evening'];
    const isGreeting = greetings.some(greeting => {
        const words = queryLower.split(/\s+/);
        return words.includes(greeting) || queryLower === greeting;
    });

    if (isGreeting) {
        const responses = [
            "Hey there! ðŸ‘‹ I'm VortexBot, your friendly assistant. I can help you with:\n\nâ€¢ Upcoming events and hackathons\nâ€¢ Registration process\nâ€¢ Payment information\nâ€¢ Club details and team info\nâ€¢ Contact information\n\nWhat would you like to know?",
            "Hello! ðŸŽ‰ Welcome to Team Vortex! I'm here to help you with events, registrations, payments, and more. What can I assist you with today?",
            "Hi! ðŸ˜Š Great to see you here! I can answer questions about our events, help with registration, explain payment methods, or tell you about Team Vortex. What interests you?",
            "Hey! ðŸš€ I'm VortexBot, your go-to assistant for all things Team Vortex. Ask me about events, registration, payments, or anything else!"
        ];
        
        const randomResponse = responses[Math.floor(Math.random() * responses.length)];
        
        return {
            response: randomResponse,
            suggestions: ['Upcoming events', 'How to register?', 'About Team Vortex', 'Contact us']
        };
    }

    // Thank you responses
    if (queryLower.includes('thank') || queryLower.includes('thanks') || queryLower.includes('thx')) {
        return {
            response: "You're welcome! ðŸ˜Š Happy to help! If you have any more questions about events, registration, or anything else, feel free to ask!",
            suggestions: ['Upcoming events', 'How to register?', 'Contact us']
        };
    }

    // Event-related queries
    if (queryLower.includes('event') || queryLower.includes('hackathon') || queryLower.includes('contest') || queryLower.includes('competition')) {
        try {
            const now = new Date();
            const upcomingEvents = await Event.find({
                status: { $ne: 'draft' },
                date: { $gte: now }
            })
            .select('title date location price registrationType')
            .sort({ date: 1 })
            .limit(3);

            if (upcomingEvents.length > 0) {
                let response = "Here are our upcoming events:\n\n";
                upcomingEvents.forEach((event, idx) => {
                    response += `${idx + 1}. ${event.title}\n`;
                    response += `   ðŸ“… ${new Date(event.date).toLocaleDateString()}\n`;
                    response += `   ðŸ“ ${event.location}\n`;
                    response += `   ðŸ’° ${event.price > 0 ? `â‚¹${event.price}` : 'Free'}\n`;
                    response += `   ðŸ‘¥ ${event.registrationType}\n\n`;
                });
                response += "Visit our Events page to register!";
                
                return {
                    response,
                    suggestions: ['How to register?', 'Event details', 'Payment methods']
                };
            }
        } catch (err) {
            console.error('Error fetching events:', err);
        }
    }

    // Registration queries
    if (queryLower.includes('register') || queryLower.includes('sign up') || queryLower.includes('join')) {
        return {
            response: "To register for an event:\n\n1. Visit the Events page\n2. Choose your event\n3. Click 'Register Now'\n4. Fill in your details\n5. Complete payment (if required)\n6. You'll receive a confirmation email\n\nNeed help with a specific event?",
            suggestions: ['Upcoming events', 'Registration fee', 'Team registration']
        };
    }

    // Payment queries
    if (queryLower.includes('payment') || queryLower.includes('fee') || queryLower.includes('price') || queryLower.includes('cost')) {
        return {
            response: "Payment Information:\n\nðŸ’³ We accept:\n- UPI payments\n- Bank transfers\n- Cash (for some events)\n\nPayment process:\n1. Register for the event\n2. Upload payment screenshot\n3. Enter UTR number\n4. Wait for admin verification (24-48 hours)\n\nAll payments are secure and verified by our team.",
            suggestions: ['Refund policy', 'Payment proof', 'Event prices']
        };
    }

    // Club information queries
    if (queryLower.includes('club') || queryLower.includes('team vortex') || queryLower.includes('about')) {
        try {
            const clubInfo = await ClubInfo.findOne();
            if (clubInfo) {
                return {
                    response: `About Team Vortex:\n\n${clubInfo.vision || 'Team Vortex is a technical club at Navkis College of Engineering focused on innovation and technology.'}\n\nOur Mission: ${clubInfo.mission || 'To foster technical excellence and innovation among students.'}\n\nVisit our website to learn more about our team and activities!`,
                    suggestions: ['Team members', 'Contact us', 'Our events']
                };
            }
        } catch (err) {
            console.error('Error fetching club info:', err);
        }
    }

    // Contact queries
    if (queryLower.includes('contact') || queryLower.includes('email') || queryLower.includes('phone') || queryLower.includes('reach')) {
        return {
            response: "Contact Team Vortex:\n\nðŸ“§ Email: teamvortexnce@gmail.com\nðŸ“± Instagram: @teamvortex_nce\nðŸ’¼ LinkedIn: Team Vortex NCE\n\nFeel free to reach out for any queries or collaborations!",
            suggestions: ['Event queries', 'Sponsorship', 'Collaboration']
        };
    }

    // Website navigation
    if (queryLower.includes('website') || queryLower.includes('page') || queryLower.includes('navigate')) {
        return {
            response: "Website Navigation:\n\nðŸ  Home - Overview and highlights\nðŸ“… Events - Upcoming and past events\nðŸ† Contests - Active competitions\nðŸ‘¥ Team - Meet our members\nðŸ¤ Sponsors - Our partners\n\nUse the navigation menu to explore!",
            suggestions: ['View events', 'Meet the team', 'Become a sponsor']
        };
    }

    return null;
}

// @route   GET /api/chatbot/data
// @desc    Get chatbot configuration and initial data
router.get('/data', async (req, res) => {
    try {
        let chatbot = await Chatbot.findOne();
        
        // Create default if doesn't exist
        if (!chatbot) {
            chatbot = new Chatbot({
                welcomeMessage: "Hi! I'm VortexBot. How can I help you today?",
                customFAQs: [
                    {
                        question: "What is Team Vortex?",
                        answer: "Team Vortex is a technical club at Navkis College of Engineering focused on innovation, technology, and student development through hackathons, workshops, and competitions.",
                        keywords: ["team vortex", "club", "about"],
                        category: "club"
                    },
                    {
                        question: "How do I register for events?",
                        answer: "Visit our Events page, select the event you want to join, click 'Register Now', fill in your details, and complete the payment if required. You'll receive a confirmation email.",
                        keywords: ["register", "sign up", "join event"],
                        category: "registration"
                    },
                    {
                        question: "What payment methods do you accept?",
                        answer: "We accept UPI payments, bank transfers, and cash for some events. After registration, upload your payment screenshot with UTR number for verification.",
                        keywords: ["payment", "pay", "fee", "money"],
                        category: "payment"
                    }
                ],
                quickReplies: [
                    { text: "Upcoming events", category: "events" },
                    { text: "How to register?", category: "registration" },
                    { text: "Contact us", category: "general" }
                ]
            });
            await chatbot.save();
        }

        res.json({
            welcomeMessage: chatbot.welcomeMessage,
            quickReplies: chatbot.quickReplies,
            settings: chatbot.settings
        });
    } catch (err) {
        console.error('Chatbot data error:', err);
        res.status(500).json({ message: 'Failed to load chatbot data' });
    }
});

// @route   POST /api/chatbot/query
// @desc    Process user query and return response with ML learning
router.post('/query', async (req, res) => {
    const { message, sessionId, previousQuery } = req.body;

    if (!message || !message.trim()) {
        return res.status(400).json({ message: 'Message is required' });
    }

    try {
        const chatbot = await Chatbot.findOne();
        
        if (!chatbot) {
            return res.json({
                response: "I'm currently being set up. Please try again later or contact us directly.",
                suggestions: [],
                responseId: null
            });
        }

        // Update analytics
        chatbot.analytics.totalQueries += 1;
        await chatbot.save();

        // 1. Check learned interactions (ML) - with improved matching
        const learnedResponse = await checkLearnedInteractions(message, chatbot);
        if (learnedResponse) {
            chatbot.analytics.resolvedQueries += 1;
            
            // Record training data
            const trainingEntry = {
                query: message,
                response: learnedResponse.response,
                wasHelpful: null, // Will be updated by feedback
                timestamp: new Date(),
                context: {
                    previousQuery: previousQuery || null,
                    sessionQueries: [],
                    userType: 'returning'
                }
            };
            chatbot.trainingData.push(trainingEntry);
            await chatbot.save();
            
            return res.json({
                response: learnedResponse.response + "\n\nðŸ’¡ (Improved from user feedback)",
                suggestions: chatbot.settings.showSuggestions 
                    ? chatbot.quickReplies.slice(0, chatbot.settings.maxSuggestions).map(qr => qr.text)
                    : [],
                responseId: trainingEntry._id,
                learnedId: learnedResponse.learnedId,
                confidence: learnedResponse.confidence,
                askFeedback: chatbot.settings.enableFeedback
            });
        }

        // 2. Try to find custom FAQ match with quality scoring
        const { match: customMatch, score: customScore } = findBestMatch(message, chatbot.customFAQs);
        
        if (customMatch && customScore > (chatbot.settings.similarityThreshold || 0.6)) {
            // Update FAQ usage
            customMatch.usageCount = (customMatch.usageCount || 0) + 1;
            customMatch.lastUsed = new Date();
            
            // ML Enhancement: Check if there's a better alternative answer
            let responseText = customMatch.answer;
            if (customMatch.alternativeAnswers && customMatch.alternativeAnswers.length > 0) {
                const bestAlternative = customMatch.alternativeAnswers
                    .sort((a, b) => b.score - a.score)[0];
                
                // Use alternative if it has significantly better score
                if (bestAlternative.score > (customMatch.qualityScore || 0) + 0.5) {
                    responseText = bestAlternative.answer;
                    bestAlternative.usageCount += 1;
                }
            }
            
            chatbot.analytics.resolvedQueries += 1;
            
            // Record successful interaction for training
            const trainingEntry = {
                query: message,
                response: responseText,
                wasHelpful: null,
                timestamp: new Date(),
                context: {
                    previousQuery: previousQuery || null,
                    sessionQueries: [],
                    userType: 'new'
                }
            };
            chatbot.trainingData.push(trainingEntry);
            
            await chatbot.save();
            
            return res.json({
                response: responseText,
                suggestions: chatbot.settings.showSuggestions 
                    ? chatbot.quickReplies.slice(0, chatbot.settings.maxSuggestions).map(qr => qr.text)
                    : [],
                responseId: trainingEntry._id,
                faqId: customMatch._id,
                confidence: customScore,
                askFeedback: chatbot.settings.enableFeedback
            });
        }

        // 3. Try automatic response from website data
        const automaticResponse = await getAutomaticResponse(message);
        
        if (automaticResponse) {
            chatbot.analytics.resolvedQueries += 1;
            
            // Record for training
            const trainingEntry = {
                query: message,
                response: automaticResponse.response,
                wasHelpful: null,
                timestamp: new Date(),
                context: {
                    previousQuery: previousQuery || null,
                    sessionQueries: [],
                    userType: 'new'
                }
            };
            chatbot.trainingData.push(trainingEntry);
            
            await chatbot.save();
            
            return res.json({
                ...automaticResponse,
                responseId: trainingEntry._id,
                askFeedback: chatbot.settings.enableFeedback
            });
        }

        // 4. No match found - Record for ML learning
        await recordUnresolvedQuery(message, chatbot, { previousQuery });

        // 5. Return fallback response
        return res.json({
            response: chatbot.settings.fallbackMessage,
            suggestions: ['Upcoming events', 'How to register?', 'Contact us'],
            responseId: null,
            askFeedback: false
        });

    } catch (err) {
        console.error('Query processing error:', err);
        res.status(500).json({
            response: "Sorry, I'm having trouble processing your request. Please try again later.",
            suggestions: [],
            responseId: null
        });
    }
});

// @route   GET /api/chatbot/config
// @desc    Get chatbot configuration (admin only)
router.get('/config', async (req, res) => {
    try {
        const chatbot = await Chatbot.findOne();
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }
        res.json(chatbot);
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
});

// @route   PUT /api/chatbot/config
// @desc    Update chatbot configuration (admin only)
router.put('/config', async (req, res) => {
    try {
        let chatbot = await Chatbot.findOne();
        
        if (!chatbot) {
            chatbot = new Chatbot(req.body);
        } else {
            Object.assign(chatbot, req.body);
        }
        
        await chatbot.save();
        res.json({ message: 'Chatbot configuration updated', chatbot });
    } catch (err) {
        res.status(400).json({ message: err.message });
    }
});

// @route   POST /api/chatbot/faq
// @desc    Add custom FAQ (admin only)
router.post('/faq', async (req, res) => {
    try {
        const chatbot = await Chatbot.findOne();
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }

        chatbot.customFAQs.push(req.body);
        await chatbot.save();
        
        res.json({ message: 'FAQ added successfully', chatbot });
    } catch (err) {
        res.status(400).json({ message: err.message });
    }
});

// @route   PUT /api/chatbot/faq/:id
// @desc    Update custom FAQ (admin only)
router.put('/faq/:id', async (req, res) => {
    try {
        const chatbot = await Chatbot.findOne();
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }

        const faqIndex = chatbot.customFAQs.findIndex(faq => faq._id.toString() === req.params.id);
        if (faqIndex === -1) {
            return res.status(404).json({ message: 'FAQ not found' });
        }

        Object.assign(chatbot.customFAQs[faqIndex], req.body);
        await chatbot.save();
        
        res.json({ message: 'FAQ updated successfully', chatbot });
    } catch (err) {
        res.status(400).json({ message: err.message });
    }
});

// @route   DELETE /api/chatbot/faq/:id
// @desc    Delete custom FAQ (admin only)
router.delete('/faq/:id', async (req, res) => {
    try {
        const chatbot = await Chatbot.findOne();
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }

        chatbot.customFAQs = chatbot.customFAQs.filter(faq => faq._id.toString() !== req.params.id);
        await chatbot.save();
        
        res.json({ message: 'FAQ deleted successfully', chatbot });
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
});

// @route   GET /api/chatbot/analytics
// @desc    Get chatbot analytics (admin only)
router.get('/analytics', async (req, res) => {
    try {
        const chatbot = await Chatbot.findOne().select('analytics');
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }
        res.json(chatbot.analytics);
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
});

// @route   GET /api/chatbot/learned
// @desc    Get learned interactions for admin review
router.get('/learned', async (req, res) => {
    try {
        const chatbot = await Chatbot.findOne().select('learnedInteractions');
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }
        
        // Sort by frequency (most asked first)
        const sorted = chatbot.learnedInteractions.sort((a, b) => b.frequency - a.frequency);
        
        res.json(sorted);
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
});

// @route   PUT /api/chatbot/learned/:id/approve
// @desc    Approve learned interaction and provide answer
router.put('/learned/:id/approve', async (req, res) => {
    try {
        const { suggestedAnswer, category } = req.body;
        const chatbot = await Chatbot.findOne();
        
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }
        
        const learned = chatbot.learnedInteractions.id(req.params.id);
        if (!learned) {
            return res.status(404).json({ message: 'Learned interaction not found' });
        }
        
        learned.suggestedAnswer = suggestedAnswer;
        learned.approved = true;
        learned.category = category || 'general';
        
        await chatbot.save();
        
        res.json({ message: 'Learned interaction approved', chatbot });
    } catch (err) {
        res.status(400).json({ message: err.message });
    }
});

// @route   DELETE /api/chatbot/learned/:id
// @desc    Delete learned interaction
router.delete('/learned/:id', async (req, res) => {
    try {
        const chatbot = await Chatbot.findOne();
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }
        
        chatbot.learnedInteractions = chatbot.learnedInteractions.filter(
            l => l._id.toString() !== req.params.id
        );
        
        await chatbot.save();
        
        res.json({ message: 'Learned interaction deleted', chatbot });
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
});

// @route   POST /api/chatbot/learned/:id/convert-to-faq
// @desc    Convert learned interaction to FAQ
router.post('/learned/:id/convert-to-faq', async (req, res) => {
    try {
        const chatbot = await Chatbot.findOne();
        
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }
        
        const learned = chatbot.learnedInteractions.id(req.params.id);
        if (!learned) {
            return res.status(404).json({ message: 'Learned interaction not found' });
        }
        
        if (!learned.approved || !learned.suggestedAnswer) {
            return res.status(400).json({ message: 'Please approve and provide answer first' });
        }
        
        // Create FAQ from learned interaction
        chatbot.customFAQs.push({
            question: learned.userQuery,
            answer: learned.suggestedAnswer,
            keywords: learned.relatedQueries.slice(0, 5), // Use related queries as keywords
            category: learned.category || 'general',
            enabled: true,
            usageCount: learned.frequency
        });
        
        // Remove from learned interactions
        chatbot.learnedInteractions = chatbot.learnedInteractions.filter(
            l => l._id.toString() !== req.params.id
        );
        
        await chatbot.save();
        
        res.json({ message: 'Converted to FAQ successfully', chatbot });
    } catch (err) {
        res.status(400).json({ message: err.message });
    }
});

// @route   POST /api/chatbot/feedback
// @desc    Submit user feedback for ML improvement
router.post('/feedback', async (req, res) => {
    try {
        const { responseId, learnedId, faqId, wasHelpful, rating, comment } = req.body;
        
        const chatbot = await Chatbot.findOne();
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }
        
        // Update analytics
        chatbot.analytics.totalFeedback += 1;
        if (wasHelpful) {
            chatbot.analytics.positiveFeedback += 1;
        } else {
            chatbot.analytics.negativeFeedback += 1;
        }
        
        // Update training data if responseId provided
        if (responseId) {
            const training = chatbot.trainingData.id(responseId);
            if (training) {
                training.wasHelpful = wasHelpful;
                training.userRating = rating || (wasHelpful ? 5 : 1);
                training.userComment = comment || '';
            }
        }
        
        // Update learned interaction feedback
        if (learnedId) {
            const learned = chatbot.learnedInteractions.id(learnedId);
            if (learned) {
                learned.userFeedback.push({
                    wasHelpful,
                    comment: comment || '',
                    timestamp: new Date()
                });
                
                // If negative feedback, try to improve
                if (!wasHelpful && chatbot.settings.enableAutoImprovement) {
                    // Mark for admin review
                    learned.approved = false;
                }
            }
        }
        
        // Update FAQ quality score
        if (faqId) {
            const faq = chatbot.customFAQs.id(faqId);
            if (faq) {
                faq.totalRatings = (faq.totalRatings || 0) + 1;
                
                if (wasHelpful) {
                    faq.positiveRatings = (faq.positiveRatings || 0) + 1;
                } else {
                    faq.negativeRatings = (faq.negativeRatings || 0) + 1;
                }
                
                // Calculate quality score (0-1 scale)
                faq.qualityScore = faq.positiveRatings / faq.totalRatings;
                
                // If quality is low and we have enough feedback, mark for review
                if (faq.totalRatings >= 10 && faq.qualityScore < 0.5) {
                    // Admin should review this FAQ
                    console.log(`FAQ "${faq.question}" has low quality score: ${faq.qualityScore}`);
                }
            }
        }
        
        // Calculate average response quality
        const totalRatings = chatbot.trainingData.filter(t => t.userRating).length;
        if (totalRatings > 0) {
            const sumRatings = chatbot.trainingData
                .filter(t => t.userRating)
                .reduce((sum, t) => sum + t.userRating, 0);
            chatbot.analytics.averageResponseQuality = sumRatings / totalRatings;
        }
        
        await chatbot.save();
        
        res.json({ 
            message: 'Feedback recorded successfully',
            thanksMessage: wasHelpful 
                ? 'Thank you! Your feedback helps me learn and improve! ðŸŽ‰'
                : 'Thank you for your feedback. I\'ll work on improving my responses! ðŸ“š'
        });
    } catch (err) {
        console.error('Feedback error:', err);
        res.status(500).json({ message: err.message });
    }
});

// @route   GET /api/chatbot/improvement-suggestions
// @desc    Get AI suggestions for improving responses (admin only)
router.get('/improvement-suggestions', async (req, res) => {
    try {
        const chatbot = await Chatbot.findOne();
        if (!chatbot) {
            return res.status(404).json({ message: 'Chatbot not configured' });
        }
        
        const suggestions = [];
        
        // Find FAQs with low quality scores
        const lowQualityFAQs = chatbot.customFAQs.filter(faq => 
            faq.totalRatings >= 5 && faq.qualityScore < 0.6
        );
        
        for (const faq of lowQualityFAQs) {
            suggestions.push({
                type: 'low_quality_faq',
                faqId: faq._id,
                question: faq.question,
                currentAnswer: faq.answer,
                qualityScore: faq.qualityScore,
                totalRatings: faq.totalRatings,
                suggestion: 'Consider revising this answer based on user feedback'
            });
        }
        
        // Find frequently asked unresolved queries
        const frequentUnresolved = chatbot.learnedInteractions
            .filter(l => !l.approved && l.frequency >= 5)
            .sort((a, b) => b.frequency - a.frequency)
            .slice(0, 10);
        
        for (const learned of frequentUnresolved) {
            suggestions.push({
                type: 'frequent_unresolved',
                learnedId: learned._id,
                query: learned.userQuery,
                frequency: learned.frequency,
                relatedQueries: learned.relatedQueries,
                autoGeneratedAnswers: learned.autoGeneratedAnswers,
                suggestion: 'This question is asked frequently. Consider creating an FAQ.'
            });
        }
        
        res.json({
            suggestions,
            summary: {
                lowQualityFAQs: lowQualityFAQs.length,
                frequentUnresolved: frequentUnresolved.length,
                averageQuality: chatbot.analytics.averageResponseQuality,
                totalFeedback: chatbot.analytics.totalFeedback
            }
        });
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
});

module.exports = router;
